{"version":3,"names":["_buffer","require","_index","_nodes","_t","_tokenMap","_types2","isExpression","isFunction","isStatement","isClassBody","isTSInterfaceBody","isTSEnumMember","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","HAS_NEWLINE","HAS_NEWLINE_OR_BlOCK_COMMENT_END","commentIsNewline","c","type","test","value","Printer","constructor","format","map","tokens","originalCode","tokenContext","TokenContext","normal","_tokens","_originalCode","_currentNode","_currentTypeId","_indent","_indentRepeat","_insideAux","_noLineTerminator","_noLineTerminatorAfterNode","_printAuxAfterOnNextUserNode","_printedComments","Set","_lastCommentLine","_innerCommentsState","_flags","tokenMap","_boundGetRawIdentifier","_printSemicolonBeforeNextNode","_printSemicolonBeforeNextToken","indent","style","length","_inputMap","_buf","Buffer","preserveFormat","compact","concise","retainLines","retainFunctionParens","auxiliaryCommentBefore","auxiliaryCommentAfter","enterDelimited","oldNoLineTerminatorAfterNode","generate","ast","TokenMap","_getRawIdentifier","bind","print","_maybeAddAuxComment","get","flags","dedent","semicolon","force","node","start","end","endMatches","getCurrentLine","indexes","getIndexes","_catchUpTo","loc","_appendChar","_queue","rightBrace","minified","removeLastSemicolon","sourceWithOffset","token","rightParens","space","_space","lastCp","getLastChar","word","str","noLineTerminatorAfter","forInOrInitHeadAccumulatePassThroughMask","_maybePrintInnerComments","_catchUpToCurrentToken","lastChar","charCodeAt","_append","setLastChar","number","isNonDecimalLiteral","secondChar","Number","isInteger","maybeNewline","occurrenceCount","mayNeedSpace","strFirst","tokenChar","char","newline","i","getNewlineCount","j","_newline","endsWith","checkQueue","_last","exactSource","cb","_catchUp","source","prop","columnOffset","sourceIdentifierName","identifierName","pos","_canMarkIdName","sourcePosition","_sourcePosition","identifierNamePos","_queuedChar","findMatching","_maybeIndent","append","noIndent","appendChar","queue","_shouldIndent","catchUp","line","count","column","index","spacesCount","getCurrentColumn","spaces","slice","replace","repeat","printTerminatorless","resetTokenContext","trailingCommentsLineOffset","_node$leadingComments","_node$leadingComments2","extra","changedFlags","_compact","nodeInfo","generatorInfosMap","undefined","ReferenceError","JSON","stringify","name","printMethod","nodeId","needsParens","parent","parentId","oldInAux","oldTokenContext","forInOrInitHeadAccumulate","parenthesized","shouldPrintParens","parentNeedsParens","leadingComments","callee","indentParenthesized","some","isLastChild","_node$trailingComment","trailingComments","_printLeadingComments","_printTrailingComments","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","_printComment","getPossibleRaw","raw","rawValue","printJoin","nodes","statement","separator","printTrailingSeparator","_nodes$0$loc","startLine","len","hasContent","call","lastCommentLine","_nodes$loc","offset","printAndIndentOnComments","printBlock","body","lineOffset","innerComments","_printComments","comments","nextTokenStr","nextTokenOccurrenceCount","_this$tokenMap","state","printInnerComments","nextToken","hasSpace","noIndentInnerCommentsHere","printSequence","printList","items","commaSeparator","shouldPrintTrailingComma","listEnd","listEndIndex","findLastIndex","matchesOriginal","String","fromCharCode","_shouldPrintComment","ignore","has","commentTok","find","add","shouldPrintComment","skipNewLines","noLineTerminator","isBlockComment","printNewLines","val","adjustMultilineComment","_comment$loc","newlineRegex","RegExp","indentSize","nodeLoc","hasLoc","nodeStartLine","nodeEndLine","lastLine","leadingCommentNewline","shouldPrint","commentStartLine","commentEndLine","Math","max","min","singleLine","shouldSkipNewline","properties","_default","exports","default","last"],"sources":["../src/printer.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n\nimport Buffer from \"./buffer.ts\";\nimport type { Loc, Pos } from \"./buffer.ts\";\nimport { isLastChild, parentNeedsParens } from \"./node/index.ts\";\nimport { generatorInfosMap } from \"./nodes.ts\";\nimport type * as t from \"@babel/types\";\nimport {\n  isExpression,\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumMember,\n} from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport { TokenMap } from \"./token-map.ts\";\n\nimport type { GeneratorOptions } from \"./index.ts\";\nimport type SourceMap from \"./source-map.ts\";\nimport type { TraceMap } from \"@jridgewell/trace-mapping\";\nimport type { Token } from \"@babel/parser\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\\n\\r\\u2028\\u2029]|\\*\\//;\n\nfunction commentIsNewline(c: t.Comment) {\n  return c.type === \"CommentLine\" || HAS_NEWLINE.test(c.value);\n}\n\nimport { TokenContext } from \"./node/index.ts\";\nimport { _getRawIdentifier } from \"./generators/types.ts\";\n\nconst enum COMMENT_TYPE {\n  LEADING,\n  INNER,\n  TRAILING,\n}\n\nconst enum COMMENT_SKIP_NEWLINE {\n  DEFAULT,\n  ALL,\n  LEADING,\n  TRAILING,\n}\n\nconst enum PRINT_COMMENT_HINT {\n  SKIP,\n  ALLOW,\n  DEFER,\n}\n\nconst enum PRINTER_FLAGS {\n  EMPTY = 0,\n  PRESERVE_FORMAT = 1 << 0,\n  COMPACT = 1 << 1,\n  CONCISE = 1 << 2,\n  RETAIN_LINES = 1 << 3,\n  RETAIN_FUNCTION_PARENS = 1 << 4,\n  AUX_COMMENTS = 1 << 5,\n}\n\nconst enum LAST_CHAR_KINDS {\n  EMPTY = 0,\n  NORMAL = -1,\n  INTEGER = -2,\n  WORD = -3,\n}\n\nconst enum INNER_COMMENTS_STATE {\n  DISALLOWED = 0,\n  ALLOWED = 1,\n  PRINTED = 2,\n\n  WITH_INDENT = 4,\n  MASK = 3,\n}\n\nconst enum PRINT_COMMENTS_RESULT {\n  PRINTED_NONE = 0,\n  PRINTED_SOME = 1,\n  PRINTED_ALL = 2,\n}\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  preserveFormat: boolean | undefined;\n  retainLines: boolean | undefined;\n  retainFunctionParens: boolean | undefined;\n  comments: boolean | undefined;\n  auxiliaryCommentBefore: string | undefined;\n  auxiliaryCommentAfter: string | undefined;\n  compact: boolean | \"auto\" | undefined;\n  minified: boolean | undefined;\n  concise: boolean | undefined;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n  };\n  /**\n   * @deprecated Removed in Babel 8, syntax type is always 'hash'\n   */\n  recordAndTupleSyntaxType?: GeneratorOptions[\"recordAndTupleSyntaxType\"];\n  jsescOption: jsescOptions;\n  /**\n   * @deprecated Removed in Babel 8, use `jsescOption` instead\n   */\n  jsonCompatibleStrings?: boolean;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodiesâ€™ topic references.\n   */\n  topicToken?: GeneratorOptions[\"topicToken\"];\n  /**\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   * @deprecated Removed in Babel 8.\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n};\n\ninterface PrintSequenceOptions {\n  statement?: boolean;\n  indent?: boolean;\n  trailingCommentsLineOffset?: number;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer, occurrenceCount: number, last: boolean) => void;\n  statement?: boolean;\n  indent?: boolean;\n  printTrailingSeparator?: boolean;\n}\n\nexport type PrintJoinOptions = PrintListOptions & PrintSequenceOptions;\nclass Printer {\n  constructor(\n    format: Format,\n    map: SourceMap | null,\n    tokens: Token[] | null = null,\n    originalCode: string | null = null,\n  ) {\n    this.format = format;\n\n    this._tokens = tokens;\n    this._originalCode = originalCode;\n\n    this._indentRepeat = format.indent.style.length;\n\n    this._inputMap = map?._inputMap || null;\n\n    this._buf = new Buffer(map, format.indent.style[0]);\n\n    const {\n      preserveFormat,\n      compact,\n      concise,\n      retainLines,\n      retainFunctionParens,\n    } = format;\n    if (preserveFormat) {\n      this._flags |= PRINTER_FLAGS.PRESERVE_FORMAT;\n    }\n    if (compact) {\n      this._flags |= PRINTER_FLAGS.COMPACT;\n    }\n    if (concise) {\n      this._flags |= PRINTER_FLAGS.CONCISE;\n    }\n    if (retainLines) {\n      this._flags |= PRINTER_FLAGS.RETAIN_LINES;\n    }\n    if (retainFunctionParens) {\n      this._flags |= PRINTER_FLAGS.RETAIN_FUNCTION_PARENS;\n    }\n    if (format.auxiliaryCommentBefore || format.auxiliaryCommentAfter) {\n      this._flags |= PRINTER_FLAGS.AUX_COMMENTS;\n    }\n  }\n  declare _inputMap: TraceMap | null;\n\n  declare format: Format;\n\n  enterDelimited() {\n    const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n    if (oldNoLineTerminatorAfterNode !== null) {\n      this._noLineTerminatorAfterNode = null;\n    }\n    return oldNoLineTerminatorAfterNode;\n  }\n\n  tokenContext: number = TokenContext.normal;\n\n  _tokens: Token[] | null = null;\n  _originalCode: string | null = null;\n\n  declare _buf: Buffer;\n  _currentNode: t.Node | null = null;\n  _currentTypeId: number | null = null;\n  _indent: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _noLineTerminator: boolean = false;\n  _noLineTerminatorAfterNode: t.Node | null = null;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _lastCommentLine = 0;\n  _innerCommentsState = INNER_COMMENTS_STATE.DISALLOWED;\n  _flags = PRINTER_FLAGS.EMPTY;\n\n  tokenMap: TokenMap | null = null;\n\n  _boundGetRawIdentifier: ((node: t.Identifier) => string) | null = null;\n\n  generate(ast: t.Node) {\n    if (this.format.preserveFormat) {\n      this.tokenMap = new TokenMap(ast, this._tokens!, this._originalCode!);\n      this._boundGetRawIdentifier = _getRawIdentifier.bind(this);\n    }\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(flags = this._flags): void {\n    if (\n      flags &\n      (PRINTER_FLAGS.PRESERVE_FORMAT |\n        PRINTER_FLAGS.COMPACT |\n        PRINTER_FLAGS.CONCISE)\n    ) {\n      return;\n    }\n\n    this._indent += this._indentRepeat;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(flags = this._flags): void {\n    if (\n      flags &\n      (PRINTER_FLAGS.PRESERVE_FORMAT |\n        PRINTER_FLAGS.COMPACT |\n        PRINTER_FLAGS.CONCISE)\n    ) {\n      return;\n    }\n\n    this._indent -= this._indentRepeat;\n  }\n\n  /**\n   * If the next token is on the same line, we must first print a semicolon.\n   * This option is only used in `preserveFormat` node, for semicolons that\n   * might have omitted due to them being absent in the original code (thanks\n   * to ASI).\n   *\n   * We need both *NextToken and *NextNode because we only want to insert the\n   * semicolon when the next token starts a new node, and not in cases like\n   * foo} (where } is not starting a new node). So we first set *NextNode, and\n   * then the print() method will move it to *NextToken.\n   */\n  _printSemicolonBeforeNextNode: number = -1;\n  _printSemicolonBeforeNextToken: number = -1;\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n  semicolon(force: boolean = false): void {\n    const flags = this._flags;\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._maybeAddAuxComment();\n    }\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) {\n      const node = this._currentNode!;\n      if (node.start != null && node.end != null) {\n        if (!this.tokenMap!.endMatches(node, \";\")) {\n          // no semicolon\n          this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();\n          return;\n        }\n        const indexes = this.tokenMap!.getIndexes(this._currentNode!)!;\n        this._catchUpTo(this._tokens![indexes[indexes.length - 1]].loc.start);\n      }\n    }\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n    } else {\n      this._queue(charCodes.semicolon);\n    }\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(node: t.Node): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\"}\");\n  }\n\n  rightParens(node: t.Node): void {\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\")\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    if (this._flags & (PRINTER_FLAGS.PRESERVE_FORMAT | PRINTER_FLAGS.COMPACT)) {\n      return;\n    }\n\n    if (force) {\n      this._space();\n    } else {\n      const lastCp = this.getLastChar(true);\n      if (\n        lastCp !== 0 &&\n        lastCp !== charCodes.space &&\n        lastCp !== charCodes.lineFeed\n      ) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string, noLineTerminatorAfter: boolean = false): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(str);\n\n    const flags = this._flags;\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._maybeAddAuxComment();\n    }\n\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) this._catchUpToCurrentToken(str);\n\n    const lastChar = this.getLastChar();\n\n    if (\n      lastChar === LAST_CHAR_KINDS.INTEGER ||\n      lastChar === LAST_CHAR_KINDS.WORD ||\n      // prevent concatenating words and creating // comment out of division and regex\n      (lastChar === charCodes.slash && str.charCodeAt(0) === charCodes.slash)\n    ) {\n      this._space();\n    }\n    this._append(str, false);\n\n    this.setLastChar(-3);\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string, number?: number): void {\n    // const NON_DECIMAL_LITERAL = /^0[box]/;\n    function isNonDecimalLiteral(str: string) {\n      if (str.length > 2 && str.charCodeAt(0) === charCodes.digit0) {\n        const secondChar = str.charCodeAt(1);\n        return (\n          secondChar === charCodes.lowercaseB ||\n          secondChar === charCodes.lowercaseO ||\n          secondChar === charCodes.lowercaseX\n        );\n      }\n      return false;\n    }\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted immediately after them.\n    if (\n      Number.isInteger(number) &&\n      !isNonDecimalLiteral(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot\n    ) {\n      this.setLastChar(LAST_CHAR_KINDS.INTEGER);\n    }\n  }\n\n  /**\n   * Writes a simple token.\n   *\n   * @param {string} str The string to append.\n   * @param {boolean} [maybeNewline=false] Wether `str` might potentially\n   *    contain a line terminator or not.\n   * @param {number} [occurrenceCount=0] The occurrence count of this token in\n   *    the current node. This is used when printing in `preserveFormat` mode,\n   *    to know which token we should map to (for example, to disambiguate the\n   *    commas in an array literal).\n   */\n  token(\n    str: string,\n    maybeNewline = false,\n    occurrenceCount = 0,\n    mayNeedSpace: boolean = false,\n  ): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(str, occurrenceCount);\n\n    const flags = this._flags;\n\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._maybeAddAuxComment();\n    }\n\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) {\n      this._catchUpToCurrentToken(str, occurrenceCount);\n    }\n\n    if (mayNeedSpace) {\n      const strFirst = str.charCodeAt(0);\n      if (\n        // space is mandatory to avoid outputting <!--\n        // http://javascript.spec.whatwg.org/#comment-syntax\n        (((strFirst === charCodes.dash && str === \"--\") ||\n          // Needs spaces to avoid changing a! == 0 to a!== 0\n          strFirst === charCodes.equalsTo) &&\n          this.getLastChar() === charCodes.exclamationMark) ||\n        // Need spaces for operators of the same kind to avoid: `a+++b`\n        (strFirst === charCodes.plusSign &&\n          this.getLastChar() === charCodes.plusSign) ||\n        (strFirst === charCodes.dash &&\n          this.getLastChar() === charCodes.dash) ||\n        // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n        (strFirst === charCodes.dot &&\n          this.getLastChar() === LAST_CHAR_KINDS.INTEGER)\n      ) {\n        this._space();\n      }\n    }\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n\n  tokenChar(char: number, occurrenceCount = 0): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(char, occurrenceCount);\n\n    const flags = this._flags;\n\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._maybeAddAuxComment();\n    }\n\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) {\n      this._catchUpToCurrentToken(char, occurrenceCount);\n    }\n\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign &&\n        this.getLastChar() === charCodes.plusSign) ||\n      (char === charCodes.dash && this.getLastChar() === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this.getLastChar() === LAST_CHAR_KINDS.INTEGER)\n    ) {\n      this._space();\n    }\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * This function checks the number of newlines in the queue and subtracts them.\n   * It currently has some limitations.\n   * @see {Buffer#getNewlineCount}\n   */\n  newline(i: number = 1, flags = this._flags): void {\n    if (i <= 0) return;\n\n    if (flags & (PRINTER_FLAGS.RETAIN_LINES | PRINTER_FLAGS.COMPACT)) {\n      return;\n    }\n\n    if (flags & PRINTER_FLAGS.CONCISE) {\n      this.space();\n      return;\n    }\n\n    if (i > 2) i = 2; // Max two lines\n\n    i -= this._buf.getNewlineCount();\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar(true) === char;\n  }\n\n  getLastChar(checkQueue?: boolean): number {\n    return this._buf.getLastChar(checkQueue);\n  }\n\n  setLastChar(char: number) {\n    this._buf._last = char;\n  }\n\n  exactSource(loc: Loc | null | undefined, cb: () => void) {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | null | undefined,\n    columnOffset: number,\n  ): void {\n    if (!loc || this.format.preserveFormat) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n\n  sourceIdentifierName(identifierName: string, pos?: Pos): void {\n    if (!this._buf._canMarkIdName) return;\n\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    // Drop trailing spaces when a newline is inserted.\n    if (this._buf._queuedChar === charCodes.space) this._buf._queuedChar = 0;\n\n    this._appendChar(charCodes.lineFeed, true);\n  }\n\n  _catchUpToCurrentToken(\n    str: string | number,\n    occurrenceCount: number = 0,\n  ): void {\n    // Assert: this.tokenMap\n\n    const token = this.tokenMap!.findMatching(\n      this._currentNode!,\n      str,\n      occurrenceCount,\n    );\n    if (token) this._catchUpTo(token.loc.start);\n\n    if (\n      this._printSemicolonBeforeNextToken !== -1 &&\n      this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()\n    ) {\n      this._appendChar(charCodes.semicolon, true);\n    }\n    this._printSemicolonBeforeNextToken = -1;\n    this._printSemicolonBeforeNextNode = -1;\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeIndent();\n\n    this._buf.append(str, maybeNewline);\n  }\n\n  _appendChar(char: number, noIndent?: boolean): void {\n    if (!noIndent) {\n      this._maybeIndent();\n    }\n\n    this._buf.appendChar(char);\n  }\n\n  _queue(char: typeof charCodes.space | typeof charCodes.semicolon): void {\n    this._buf.queue(char);\n\n    this.setLastChar(-1);\n  }\n\n  _maybeIndent(): void {\n    const indent = this._shouldIndent();\n    if (indent > 0) {\n      this._buf._appendChar(-1, indent, false);\n    }\n  }\n\n  _shouldIndent() {\n    // we've got a newline before us so prepend on the indentation\n    return this.endsWith(charCodes.lineFeed) ? this._indent : 0;\n  }\n\n  catchUp(line: number) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const count = line - this._buf.getCurrentLine();\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    const flags = this._flags;\n    if ((flags & PRINTER_FLAGS.PRESERVE_FORMAT) === 0) {\n      if (flags & PRINTER_FLAGS.RETAIN_LINES && loc?.[prop]) {\n        this.catchUp(loc[prop].line);\n      }\n      return;\n    }\n\n    // catch up to this nodes newline if we're behind\n    const pos = loc?.[prop];\n    if (pos != null) this._catchUpTo(pos);\n  }\n\n  _catchUpTo({ line, column, index }: Pos) {\n    const count = line - this._buf.getCurrentLine();\n    if (count > 0 && this._noLineTerminator) {\n      // We cannot inject new lines when _noLineTemrinator is set\n      // to `true`, or we would generate invalid code.\n      return;\n    }\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n\n    const spacesCount =\n      count > 0 ? column : column - this._buf.getCurrentColumn();\n    if (spacesCount > 0) {\n      const spaces = this._originalCode\n        ? this._originalCode\n            .slice(index - spacesCount, index)\n            // https://tc39.es/ecma262/#sec-white-space\n            .replace(/[^\\t\\v\\f\\uFEFF\\p{Space_Separator}]/gu, \" \")\n        : \" \".repeat(spacesCount);\n      this._append(spaces, false);\n      this.setLastChar(charCodes.space);\n    }\n  }\n\n  printTerminatorless(node: t.Node) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    this._noLineTerminator = true;\n    this.print(node);\n  }\n\n  print(\n    node: t.Node | null | undefined,\n    noLineTerminatorAfter: boolean = false,\n    resetTokenContext: boolean = false,\n    // trailingCommentsLineOffset also used to check if called from printJoin\n    // it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!node) return;\n\n    this._innerCommentsState = INNER_COMMENTS_STATE.DISALLOWED;\n\n    const { type, loc, extra } = node;\n\n    const flags = this._flags;\n    let changedFlags = false;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      this._flags |= PRINTER_FLAGS.CONCISE;\n      changedFlags = true;\n    }\n\n    const nodeInfo = generatorInfosMap.get(type);\n    if (nodeInfo === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          type,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    const [printMethod, nodeId, needsParens] = nodeInfo;\n\n    const parent = this._currentNode;\n    const parentId = this._currentTypeId;\n    this._currentNode = node;\n    this._currentTypeId = nodeId;\n\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) {\n      this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;\n    }\n\n    let oldInAux;\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      oldInAux = this._insideAux;\n      this._insideAux = loc == null;\n      this._maybeAddAuxComment(this._insideAux && !oldInAux);\n    }\n\n    let oldTokenContext = 0;\n    if (resetTokenContext) {\n      oldTokenContext = this.tokenContext;\n      if (oldTokenContext & TokenContext.forInOrInitHeadAccumulate) {\n        this.tokenContext = 0;\n      } else {\n        oldTokenContext = 0;\n      }\n    }\n\n    const parenthesized =\n      extra != null && (extra.parenthesized as boolean | undefined);\n    let shouldPrintParens =\n      (parenthesized && flags & PRINTER_FLAGS.PRESERVE_FORMAT) ||\n      (parenthesized &&\n        flags & PRINTER_FLAGS.RETAIN_FUNCTION_PARENS &&\n        nodeId === __node(\"FunctionExpression\")) ||\n      (parent &&\n        (parentNeedsParens(node, parent, parentId!) ||\n          // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n          (needsParens != null &&\n            needsParens(\n              node,\n              parent,\n              parentId!,\n              this.tokenContext,\n              flags & PRINTER_FLAGS.PRESERVE_FORMAT\n                ? this._boundGetRawIdentifier!\n                : undefined,\n            ))));\n\n    if (\n      !shouldPrintParens &&\n      parenthesized &&\n      node.leadingComments?.length &&\n      node.leadingComments[0].type === \"CommentBlock\"\n    ) {\n      switch (parentId) {\n        case __node(\"ExpressionStatement\"):\n        case __node(\"VariableDeclarator\"):\n        case __node(\"AssignmentExpression\"):\n        case __node(\"ReturnStatement\"):\n          break;\n        case __node(\"CallExpression\"):\n        case __node(\"OptionalCallExpression\"):\n        case __node(\"NewExpression\"):\n          // @ts-expect-error checked by parentTypeId\n          if (parent.callee !== node) break;\n        // falls through\n        default:\n          shouldPrintParens = true;\n      }\n    }\n\n    let indentParenthesized = false;\n    if (\n      !shouldPrintParens &&\n      this._noLineTerminator &&\n      (node.leadingComments?.some(commentIsNewline) ||\n        (flags & PRINTER_FLAGS.RETAIN_LINES &&\n          loc &&\n          loc.start.line > this._buf.getCurrentLine()))\n    ) {\n      shouldPrintParens = true;\n      indentParenthesized = true;\n    }\n\n    let oldNoLineTerminatorAfterNode;\n    if (!shouldPrintParens) {\n      noLineTerminatorAfter ||=\n        !!parent &&\n        this._noLineTerminatorAfterNode === parent &&\n        isLastChild(parent, node);\n      if (noLineTerminatorAfter) {\n        if (node.trailingComments?.some(commentIsNewline)) {\n          if (isExpression(node)) shouldPrintParens = true;\n        } else {\n          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n          this._noLineTerminatorAfterNode = node;\n        }\n      }\n    }\n\n    if (shouldPrintParens) {\n      this.token(\"(\");\n      if (indentParenthesized) this.indent();\n      this._innerCommentsState = INNER_COMMENTS_STATE.DISALLOWED;\n      if (!resetTokenContext) {\n        oldTokenContext = this.tokenContext;\n      }\n      if (oldTokenContext & TokenContext.forInOrInitHeadAccumulate) {\n        this.tokenContext = 0;\n      }\n      oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n      this._noLineTerminatorAfterNode = null;\n    }\n