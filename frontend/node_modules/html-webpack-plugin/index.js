// @ts-check
"use strict";

const promisify = require("util").promisify;

const vm = require("vm");
const fs = require("fs");
const _uniq = require("lodash/uniq");
const path = require("path");
const { CachedChildCompilation } = require("./lib/cached-child-compiler");

const {
  createHtmlTagObject,
  htmlTagObjectToString,
  HtmlTagArray,
} = require("./lib/html-tags");
const prettyError = require("./lib/errors.js");
const chunkSorter = require("./lib/chunksorter.js");
const { AsyncSeriesWaterfallHook } = require("tapable");

/** @typedef {import("./typings").HtmlTagObject} HtmlTagObject */
/** @typedef {import("./typings").Options} HtmlWebpackOptions */
/** @typedef {import("./typings").ProcessedOptions} ProcessedHtmlWebpackOptions */
/** @typedef {import("./typings").TemplateParameter} TemplateParameter */
/** @typedef {import("webpack").Compiler} Compiler */
/** @typedef {import("webpack").Compilation} Compilation */
/** @typedef {Required<Compilation["outputOptions"]["publicPath"]>} PublicPath */
/** @typedef {ReturnType<Compiler["getInfrastructureLogger"]>} Logger */
/** @typedef {Compilation["entrypoints"] extends Map<string, infer I> ? I : never} Entrypoint */
/** @typedef {Array<{ name: string, source: import('webpack').sources.Source, info?: import('webpack').AssetInfo }>} PreviousEmittedAssets */
/** @typedef {{ publicPath: string, js: Array<string>, css: Array<string>, manifest?: string, favicon?: string }} AssetsInformationByGroups */
/** @typedef {import("./typings").Hooks} HtmlWebpackPluginHooks */
/**
 * @type {WeakMap<Compilation, HtmlWebpackPluginHooks>}}
 */
const compilationHooksMap = new WeakMap();

class HtmlWebpackPlugin {
  // The following is the API definition for all available hooks
  // For the TypeScript definition, see the Hooks type in typings.d.ts
  /**
   beforeAssetTagGeneration:
   AsyncSeriesWaterfallHook<{
      assets: {
        publicPath: string,
        js: Array<string>,
        css: Array<string>,
        favicon?: string | undefined,
        manifest?: string | undefined
      },
      outputName: string,
      plugin: HtmlWebpackPlugin
    }>,
   alterAssetTags:
   AsyncSeriesWaterfallHook<{
      assetTags: {
        scripts: Array<HtmlTagObject>,
        styles: Array<HtmlTagObject>,
        meta: Array<HtmlTagObject>,
      },
      publicPath: string,
      outputName: string,
      plugin: HtmlWebpackPlugin
    }>,
   alterAssetTagGroups:
   AsyncSeriesWaterfallHook<{
      headTags: Array<HtmlTagObject | HtmlTagObject>,
      bodyTags: Array<HtmlTagObject | HtmlTagObject>,
      publicPath: string,
      outputName: string,
      plugin: HtmlWebpackPlugin
    }>,
   afterTemplateExecution:
   AsyncSeriesWaterfallHook<{
      html: string,
      headTags: Array<HtmlTagObject | HtmlTagObject>,
      bodyTags: Array<HtmlTagObject | HtmlTagObject>,
      outputName: string,
      plugin: HtmlWebpackPlugin,
    }>,
   beforeEmit:
   AsyncSeriesWaterfallHook<{
      html: string,
      outputName: string,
      plugin: HtmlWebpackPlugin,
    }>,
   afterEmit:
   AsyncSeriesWaterfallHook<{
      outputName: string,
      plugin: HtmlWebpackPlugin
    }>
   */

  /**
   * Returns all public hooks of the html webpack plugin for the given compilation
   *
   * @param {Compilation} compilation
   * @returns {HtmlWebpackPluginHooks}
   */
  static getCompilationHooks(compilation) {
    let hooks = compilationHooksMap.get(compilation);

    if (!hooks) {
      hooks = {
        beforeAssetTagGeneration: new AsyncSeriesWaterfallHook(["pluginArgs"]),
        alterAssetTags: new AsyncSeriesWaterfallHook(["pluginArgs"]),
        alterAssetTagGroups: new AsyncSeriesWaterfallHook(["pluginArgs"]),
        afterTemplateExecution: new AsyncSeriesWaterfallHook(["pluginArgs"]),
        beforeEmit: new AsyncSeriesWaterfallHook(["pluginArgs"]),
        afterEmit: new AsyncSeriesWaterfallHook(["pluginArgs"]),
      };
      compilationHooksMap.set(compilation, hooks);
    }

    return hooks;
  }

  /**
   * @param {HtmlWebpackOptions} [options]
   */
  constructor(options) {
    /** @type {HtmlWebpackOptions} */
    // TODO remove me in the next major release
    this.userOptions = options || {};
    this.version = HtmlWebpackPlugin.version;

    // Default options
    /** @type {ProcessedHtmlWebpackOptions} */
    const defaultOptions = {
      template: "auto",
      templateContent: false,
      templateParameters: templateParametersGenerator,
      filename: "index.html",
      publicPath:
        this.userOptions.publicPath === undefined
          ? "auto"
          : this.userOptions.publicPath,
      hash: false,
      inject: this.userOptions.scriptLoading === "blocking" ? "body" : "head",
      scriptLoading: "defer",
      compile: true,
      favicon: false,
      minify: "auto",
      cache: true,
      showErrors: true,
      chunks: "all",
      excludeChunks: [],
      chunksSortMode: "auto",
      meta: {},
      base: false,
      title: "Webpack App",
      xhtml: false,
    };

    /** @type {ProcessedHtmlWebpackOptions} */
    this.options = Object.assign(defaultOptions, this.userOptions);
  }

  /**
   *
   * @param {Compiler} compiler
   * @returns {void}
   */
  apply(compiler) {
    this.logger = compiler.getInfrastructureLogger("HtmlWebpackPlugin");

    const options = this.options;

    options.template = this.getTemplatePath(
      this.options.template,
      compiler.context,
    );

    // Assert correct option spelling
    if (
      options.scriptLoading !== "defer" &&
      options.scriptLoading !== "blocking" &&
      options.scriptLoading !== "module" &&
      options.scriptLoading !== "systemjs-module"
    ) {
      /** @type {Logger} */
      (this.logger).error(
        'The "scriptLoading" option need to be set to "defer", "blocking" or "module" or "systemjs-module"',
      );
    }

    if (
      options.inject !== true &&
      options.inject !== false &&
      options.inject !== "head" &&
      options.inject !== "body"
    ) {
      /** @type {Logger} */
      (this.logger).error(
        'The `inject` option needs to be set to true, false, "head" or "body',
      );
    }

    if (
      this.options.templateParameters !== false &&
      typeof this.options.templateParameters !== "function" &&
      typeof this.options.templateParameters !== "object"
    ) {
      /** @type {Logger} */
      (this.logger).error(
        "The `templateParameters` has to be either a function or an object or false",
      );
    }

    // Default metaOptions if no template is provided
    if (
      !this.userOptions.template &&
      options.templateContent === false &&
      options.meta
    ) {
      options.meta = Object.assign(
        {},
        options.meta,
        {
          // TODO remove in the next major release
          // From https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag
          viewport: "width=device-width, initial-scale=1",
        },
        this.userOptions.meta,
      );
    }

    // entryName to fileName conversion function
    const userOptionFilename =
      this.userOptions.filename || this.options.filename;
    const filenameFunction =
      typeof userOptionFilename === "function"
        ? userOptionFilename
        : // Replace '[name]' with entry name
          (entryName) => userOptionFilename.replace(/\[name\]/g, entryName);

    /** output filenames for the given entry names */
    const entryNames = Object.keys(compiler.options.entry);
    const outputFileNames = new Set(
      (entryNames.length ? entryNames : ["main"]).map(filenameFunction),
    );

    // Hook all options into the webpack compiler
    outputFileNames.forEach((outputFileName) => {
      // Instance variables to keep caching information for multiple builds
      const assetJson = { value: undefined };
      /**
       * store the previous generated asset to emit them even if the content did not change
       * to support watch mode for third party plugins like the clean-webpack-plugin or the compression plugin
       * @type {PreviousEmittedAssets}
       */
      const previousEmittedAssets = [];

      // Inject child compiler plugin
      const childCompilerPlugin = new CachedChildCompilation(compiler);

      if (!this.options.templateContent) {
        childCompilerPlugin.addEntry(this.options.template);
      }

      // convert absolute filename into relative so that webpack can
      // generate it at correct location
      let filename = outputFileName;

      if (path.resolve(filename) === path.normalize(filename)) {
        const outputPath =
          /** @type {string} - Once initialized the path is always a string */ (
            compiler.options.output.path
          );

        filename = path.relative(outputPath, filename);
      }

      compiler.hooks.thisCompilation.tap(
        "HtmlWebpackPlugin",
        /**
         * Hook into the webpack compilation
         * @param {Compilation} compilation
         */
        (compilation) => {
          compilation.hooks.processAssets.tapAsync(
            {
              name: "HtmlWebpackPlugin",
              stage:
                /**
                 * Generate the html after minification and dev tooling is done
                 */
                compiler.webpack.Compilation
                  .PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE,
            },
            /**
             * Hook into the process assets hook
             * @param {any} _
             * @param {(err?: Error) => void} callback
             */
            (_, callback) => {
              this.generateHTML(
                compiler,
                compilation,
                filename,
                childCompilerPlugin,
                previousEmittedAssets,
                assetJson,
                callback,
              );
            },
          );
        },
      );
    });
  }

  /**
   * Helper to return the absolute template path with a fallback loader
   *
   * @private
   * @param {string} template The path to the template e.g. './index.html'
   * @param {string} context The webpack base resolution path for relative paths e.g. process.cwd()
   */
  getTemplatePath(template, context) {
    if (template === "auto") {
      template = path.resolve(context, "src/index.ejs");
      if (!fs.existsSync(template)) {
        template = path.join(__dirname, "default_index.ejs");
      }
    }

    // If the template doesn't use a loader use the lodash template loader
    if (template.indexOf("!") === -1) {
      template =
        require.resolve("./lib/loader.js") +
        "!" +
        path.resolve(context, template);
    }

    // Resolve template path
    return template.replace(
      /([!])([^/\\][^!?]+|[^/\\!?])($|\?[^!?\n]+$)/,
      (match, prefix, filepath, postfix) =>
        prefix + path.resolve(filepath) + postfix,
    );
  }

  /**
   * Return all chunks from the compilation result which match the exclude and include filters
   *
   * @private
   * @param {any} chunks
   * @param {string[]|'all'} includedChunks
   * @param {string[]} excludedChunks
   */
  filterEntryChunks(chunks, includedChunks, excludedChunks) {
    return chunks.filter((chunkName) => {
      // Skip if the chunks should be filtered and the given chunk was not added explicity
      if (
        Array.isArray(includedChunks) &&
        includedChunks.indexOf(chunkName) === -1
      ) {
        return false;
      }

      // Skip if the chunks should be filtered and the given chunk was excluded explicity
      if (
        Array.isArray(excludedChunks) &&
        excludedChunks.indexOf(chunkName) !== -1
      ) {
        return false;
      }

      // Add otherwise
      return true;
    });
  }

  /**
   * Helper to sort chunks
   *
   * @private
   * @param {string[]} entryNames
   * @param {string|((entryNameA: string, entryNameB: string) => number)} sortMode
   * @param {Compilation} compilation
   */
  sortEntryChunks(entryNames, sortMode, compilation) {
    // Custom function
    if (typeof sortMode === "function") {
      return entryNames.sort(sortMode);
    }
    // Check if the given sort mode is a valid chunkSorter sort mode
    if (typeof chunkSorter[sortMode] !== "undefined") {
      return chunkSorter[sortMode](entryNames, compilation, this.options);
    }
    throw new Error('"' + sortMode + '" is not a valid chunk sort mode');
  }

  /**
   * Encode each path component using `encodeURIComponent` as files can contain characters
   * which needs special encoding in URLs like `+ `.
   *
   * Valid filesystem characters which need to be encoded for urls:
   *
   * # pound, % percent, & ampersand, { left curly bracket, } right curly bracket,
   * \ back slash, < left angle bracket, > right angle bracket, * asterisk, ? question mark,
   * blank spaces, $ dollar sign, ! exclamation point, ' single quotes, " double quotes,
   * : colon, @ at sign, + plus sign, ` backtick, | pipe, = equal sign
   *
   * However the query string must not be encoded:
   *
   *  fo:demonstration-path/very fancy+name.js?path=/home?value=abc&value=def#zzz
   *    ^             ^    ^    ^     ^    ^  ^    ^^    ^     ^   ^     ^   ^
   *    |             |    |    |     |    |  |    ||    |     |   |     |   |
   *    encoded       |    |    encoded    |  |    ||    |     |   |     |   |
   *                 ignored              ignored  ignored     ignored   ignored
   *
   * @private
   * @param {string} filePath
   */
  urlencodePath(filePath) {
    // People use the filepath in quite unexpected ways.
    // Try to extract the first querystring of the url:
    //
    // some+path/demo.html?value=abc?def
    //
    const queryStringStart = filePath.indexOf("?");
    const urlPath =
      queryStringStart === -1 ? filePath : filePath.substr(0, queryStringStart);
    const queryString = filePath.substr(urlPath.length);
    // Encode all parts except '/' which are not part of the querystring:
    const encodedUrlPath = urlPath.split("/").map(encodeURIComponent).join("/");
    return encodedUrlPath + queryString;
  }

  /**
   * Appends a cache busting hash to the query string of the url
   * E.g. http://localhost:8080/ -> http://localhost:8080/?50c9096ba6183fd728eeb065a26ec175
   *
   * @private
   * @param {string | undefined} url
   * @param {string} hash
   */
  appendHash(url, hash) {
    if (!url) {
      return url;
    }

    return url + (url.indexOf("?") === -1 ? "?" : "&") + hash;
  }

  /**
   * Generate the relative or absolute base url to reference images, css, and javascript files
   * from within the html file - the publicPath
   *
   * @private
   * @param {Compilation} compilation
   * @param {string} filename
   * @param {string | 'auto'} customPublicPath
   * @returns {string}
   */
  getPublicPath(compilation, filename, customPublicPath) {
    /**
     * @type {string} the configured public path to the asset root
     * if a path publicPath is set in the current webpack config use it otherwise
     * fallback to a relative path
     */
    const webpackPublicPath = compilation.getAssetPath(
      /** @type {NonNullable<Compilation["outputOptions"]["publicPath"]>} */ (
        compilation.outputOptions.publicPath
      ),
      { hash: compilation.hash },
    );
    // Webpack 5 introduced "auto" as default value
    const isPublicPathDefined = webpackPublicPath !== "auto";

    let publicPath =
      // If the html-webpack-plugin options contain a custom public path unset it
      customPublicPath !== "auto"
        ? customPublicPath
        : isPublicPathDefined
          ? // If a hard coded public path exists use it
            webpackPublicPath
          : // If no public path was set get a relative url path
            path
              .relative(
                path.resolve(
                  /** @type {string} */ (compilation.options.output.path),
                  path.dirname(filename),
                ),
                /** @type {string} */ (compilation.options.output.path),
              )
              .split(path.sep)
              .join("/");

    if (publicPath.length && publicPath.substr(-1, 1) !== "/") {
      publicPath += "/";
    }

    return publicPath;
  }

  /**
   * The getAssetsForHTML extracts the asset information of a webpack compilation for all given entry names.
   *
   * @private
   * @param {Compilation} compilation
   * @param {string} outputName
   * @param {string[]} entryNames
   * @returns {AssetsInformationByGroups}
   */
  getAssetsInformationByGroups(compilation, outputName, entryNames) {
    /** The public path used inside the html file */
    const publicPath = this.getPublicPath(
      compilation,
      outputName,
      this.options.publicPath,
    );
    /**
     * @type {AssetsInformationByGroups}
     */
    const assets = {
      // The public path
      publicPath,
      // Will contain all js and mjs files
      js: [],
      // Will contain all css files
      css: [],
      // Will contain the html5 appcache manifest files if it exists
      manifest: Object.keys(compilation.assets).find(
        (assetFile) => path.extname(assetFile) === ".appcache",
      ),
      // Favicon
      favicon: undefined,
    };

    // Append a hash for cache busting
    if (this.options.hash && assets.manifest) {
      assets.manifest = this.appendHash(
        assets.manifest,
        /** @type {string} */ (compilation.hash),
      );
    }

    // Extract paths to .js, .mjs and .css files from the current compilation
    const entryPointPublicPathMap = {};
    const extensionRegexp = /\.(css|js|mjs)(\?|$)/;

    for (let i = 0; i < entryNames.length; i++) {
      const entryName = entryNames[i];
      /** entryPointUnfilteredFiles - also includes hot module update files */
      const entryPointUnfilteredFiles = /** @type {Entrypoint} */ (
        compilation.entrypoints.get(entryName)
      ).getFiles();
      const entryPointFiles = entryPointUnfilteredFiles.filter((chunkFile) => {
        const asset = compilation.getAsset(chunkFile);

        if (!asset) {
          return true;
        }

        // Prevent hot-module files from being included:
        const assetMetaInformation = asset.info || {};

        return !(
          assetMetaInformation.hotModuleReplacement ||
          assetMetaInformation.development
        );
      });
      // Prepend the publicPath and append the hash depending on the
      // webpack.output.publicPath and hashOptions
      // E.g. bundle.js -> /bundle.js?hash
      const entryPointPublicPaths = entryPointFiles.map((chunkFile) => {
        const entryPointPublicPath = publicPath + this.urlencodePath(chunkFile);
        return this.options.hash
          ? this.appendHash(
              entryPointPublicPath,
              /** @type {string} */ (compilation.hash),
            )
          : entryPointPublicPath;
      });

      entryPointPublicPaths.forEach((entryPointPublicPath) => {
        const extMatch = extensionRegexp.exec(
          /** @type {string} */ (entryPointPublicPath),
        );

        // Skip if the public path is not a .css, .mjs or .js file
        if (!extMatch) {
          return;
        }

        // Skip if this file is already known
        // (e.g. because of common chunk optimizations)
        if (entryPointPublicPathMap[entryPointPublicPath]) {
          return;
        }

        entryPointPublicPathMap[entryPointPublicPath] = true;

        // ext will contain .js or .css, because .mjs recognizes as .js
        const ext = extMatch[1] === "mjs" ? "js" : extMatch[1];

        assets[ext].push(entryPointPublicPath);
      });
    }

    return assets;
  }

  /**
   * Once webpack is done with compiling the template into a NodeJS code this function
   * evaluates it to generate the html result
   *
   * The evaluateCompilationResult is only a class function to allow spying during testing.
   * Please change that in a further refactoring
   *
   * @param {string} source
   * @param {string} publicPath
   * @param {string} templateFilename
   * @returns {Promise<string | (() => string | Promise<string>)>}
   */
  evaluateCompilationResult(source, publicPath, templateFilename) {
    if (!source) {
      return Promise.reject(
        new Error("The child compilation didn't provide a result"),
      );
    }

    // The LibraryTemplatePlugin stores the template result in a local variable.
    // By adding it to the end the value gets extracted during evaluation
    if (source.indexOf("HTML_WEBPACK_PLUGIN_RESULT") >= 0) {
      source += ";\nHTML_WEBPACK_PLUGIN_RESULT";
    }

    const templateWithoutLoaders = templateFilename
      .replace(/^.+!/, "")
      .replace(/\?.+$/, "");
    const globalClone = Object.create(
      Object.getPrototypeOf(global),
      Object.getOwnPropertyDescriptors(global),
    );
    // Presence of `eval` and `Function` breaks template's explicit `eval` call
    // Ref: https://github.com/nodejs/help/issues/2880
    delete globalClone.eval;
    delete globalClone.Function;
    // Not using `...global` as it throws when localStorage is not explicitly enabled in Node 25+
    const vmContext = vm.createContext(
      Object.assign(globalClone, {
        HTML_WEBPACK_PLUGIN: true,
        // Copying nonstandard globals like `require` explicitly as they may be absent from `global`
        require: require,
        htmlWebpackPluginPublicPath: publicPath,
        __filename: templateWithoutLoaders,
        __dirname: path.dirname(templateWithoutLoaders),
      }),
    );

    const vmScript = new vm.Script(source, {
      filename: templateWithoutLoaders,
    });

    // Evaluate code and cast to string
    let newSource;

    try {
      newSource = vmScript.runInContext(vmContext);
    } catch (e) {
      return Promise.reject(e);
    }

    if (
      typeof newSource === "object" &&
      newSource.__esModule &&
      newSource.default !== undefined
    ) {
      newSource = newSource.default;
    }

    return typeof newSource === "string" || typeof newSource === "function"
      ? Promise.resolve(newSource)
      : Promise.reject(
          new Error(
            'The loader "' + templateWithoutLoaders + "\" didn't return html.",
          ),
        );
  }

  /**
   * Add toString methods for easier rendering inside the template
   *
   * @private
   * @param {Array<HtmlTagObject>} assetTagGroup
   * @returns {Array<HtmlTagObject>}
   */
  prepareAssetTagGroupForRendering(assetTagGroup) {
    const xhtml = this.options.xhtml;
    return HtmlTagArray.from(
      assetTagGroup.map((assetTag) => {
        const copiedAssetTag = Object.assign({}, assetTag);
        copiedAssetTag.toString = function () {
          return htmlTagObjectToString(this, xhtml);
        };
        return copiedAssetTag;
      }),
    );
  }

  /**
   * Generate the template parameters for the template function
   *
   * @private
   * @param {Compilation} compilation
   * @param {AssetsInformationByGroups} assetsInformationByGroups
   * @param {{
       headTags: HtmlTagObject[],
       bodyTags: HtmlTagObject[]
     }} assetTags
   * @returns {Promise<{[key: any]: any}>}
   */
  getTemplateParameters(compilation, assetsInformationByGroups, assetTags) {
    const templateParameters = this.options.templateParameters;

    if (templateParameters === false) {
      return Promise.resolve({});
    }

    if (
      typeof templateParameters !== "function" &&
      typeof templateParameters !== "object"
    ) {
      throw new Error(
        "templateParameters has to be either a function or an object",
      );
    }

    const templateParameterFunction =
      typeof templateParameters === "function"
        ? // A custom function can overwrite the entire template parameter preparation
          templateParameters
        : // If the template parameters is an object merge it with the default values
          (compilation, assetsInformationByGroups, assetTags, options) =>
            Object.assign(
              {},
              templateParametersGenerator(
                compilation,
                assetsInformationByGroups,
                assetTags,
                options,
              ),
              templateParameters,
            );
    const preparedAssetTags = {
      headTags: this.prepareAssetTagGroupForRendering(assetTags.headTags),
      bodyTags: this.prepareAssetTagGroupForRendering(assetTags.bodyTags),
    };
    return Promise.resolve().then(() =>
      templateParameterFunction(
        compilation,
        assetsInformationByGroups,
        preparedAssetTags,
        this.options,
      ),
    );
  }

  /**
   * This function renders the actual html by executing the template function
   *
   * @private
   * @param {(templateParameters) => string | Promise<string>} templateFunction
   * @param {AssetsInformationByGroups} assetsInformationByGroups
   * @param {{
       headTags: HtmlTagObject[],
       bodyTags: HtmlTagObject[]
     }} assetTags
   * @param {Compilation} compilation
   * @returns Promise<string>
   */
  executeTemplate(
    templateFunction,
    assetsInformationByGroups,
    assetTags,
    compilation,
  ) {
    // Template processing
    const templateParamsPromise = this.getTemplateParameters(
      compilation,
      assetsInformationByGroups,
      assetTags,
    );

    return templateParamsPromise.then((templateParams) => {
      try {
        // If html is a promise return the promise
        // If html is a string turn it into a promise
        return templateFunction(templateParams);
      } catch (e) {
        // @ts-ignore
        compilation.errors.push(new Error("Template execution failed: " + e));
        return Promise.reject(e);
      }
    });
  }

  /**
   * Html Post processing
   *
   * @private
   * @param {Compiler} compiler The compiler instance
   * @param {any} originalHtml The input html
   * @param {AssetsInformationByGroups} assetsInformationByGroups
   * @param {{headTags: HtmlTagObject[], bodyTags: HtmlTagObject[]}} assetTags The asset tags to inject
   * @returns {Promise<string>}
   */
  postProcessHtml(
    compiler,
    originalHtml,
    assetsInformationByGroups,
    assetTags,
  ) {
    let html = originalHtml;

    if (typeof html !== "string") {
      return Promise.reject(
        new Error(
          "Expected html to be a string but got " + JSON.stringify(html),
        ),
      );
    }

    if (this.options.inject) {
      const htmlRegExp = /(<html[^>]*>)/i;
      const headRegExp = /(<\/head\s*>)/i;
      const bodyRegExp = /(<\/body\s*>)/i;
      const metaViewportRegExp = /<meta[^>]+name=["']viewport["'][^>]*>/i;
      const body = assetTags.bodyTags.map((assetTagObject) =>
        htmlTagObjectToString(assetTagObject, this.options.xhtml),
      );
      const head = assetTags.headTags
        .filter((item) => {
          if (
            item.tagName === "meta" &&
            item.attributes &&
            item.attributes.name === "viewport" &&
            metaViewportRegExp.test(html)
          ) {
            return false;
          }

          return true;
        })
        .map((assetTagObject) =>
          htmlTagObjectToString(assetTagObject, this.options.xhtml),
        );

      if (body.length) {
        if (bodyRegExp.test(html)) {
          // Append assets to body element
          html = html.replace(bodyRegExp, (match) => body.join("") + match);
        } else {
          // Append scripts to the end of the file if no <body> element exists:
          html += body.join("");
        }
      }

      if (head.length) {
        // Create a head tag if none exists
        if (!headRegExp.test(html)) {
          if (!htmlRegExp.test(html)) {
            html = "<head></head>" + html;
          } else {
            html = html.replace(htmlRegExp, (match) => match + "<head></head>");
          }
        }

        // Append assets to head element
        html = html.replace(headRegExp, (match) => head.join("") + match);
      }

      // Inject manifest into the opening html tag
      if (assetsInformationByGroups.manifest) {
        html = html.replace(/(<html[^>]*)(>)/i, (match, start, end) => {
          // Append the manifest only if no manifest was specified
          if (/\smanifest\s*=/.test(match)) {
            return match;
          }
          return (
            start +
            ' manifest="' +
            assetsInformationByGroups.manifest +
            '"' +
            end
          );
        });
      }
    }

    // TODO avoid this logic and use https://github.com/webpack-contrib/html-minimizer-webpack-plugin under the hood in the next major version
    // Check if webpack is running in production mode
    // @see https://github.com/webpack/webpack/blob/3366421f1784c449f415cda5930a8e445086f688/lib/WebpackOptionsDefaulter.js#L12-L14
    const isProductionLikeMode =
      compiler.options.mode === "production" || !compiler.options.mode;
    const needM